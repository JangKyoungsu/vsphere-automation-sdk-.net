<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>VMware vSphere Automation SDK for .NET 7.0.1.0: vmware::vcenter::Host Interface Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.4 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">VMware vSphere Automation SDK for .NET 7.0.1.0</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('interfacevmware_1_1vcenter_1_1Host.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">vmware::vcenter::Host Interface Reference</div>  </div>
</div>
<div class="contents">
<!-- doxytag: class="vmware::vcenter::Host" -->
<p>The <code><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html" title="The Host interface provides methods to manage hosts in the vCenter Server.">Host</a></code> interface provides methods to manage hosts in the vCenter Server.  
 <a href="interfacevmware_1_1vcenter_1_1Host.html#details">More...</a></p>

<p>Inherited by <a class="el" href="classvmware_1_1vcenter_1_1HostStub.html">vmware::vcenter::HostStub</a>.</p>

<p><a href="interfacevmware_1_1vcenter_1_1Host-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html#a4f42185e7c162aec3fcdca5b10cd9877">Create</a> (<a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1CreateSpec.html">vmware.vcenter.HostTypes.CreateSpec</a> spec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new standalone host in the vCenter inventory.  <a href="#a4f42185e7c162aec3fcdca5b10cd9877"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html#a5abd97e980f62febc5400415d9a67430">Create</a> (<a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1CreateSpec.html">vmware.vcenter.HostTypes.CreateSpec</a> spec, global::System.Action&lt; vmware.vapi.std.Progress &gt; _progress, vmware.vapi.bindings.client.InvocationConfig _invocationConfig)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new standalone host in the vCenter inventory.  <a href="#a5abd97e980f62febc5400415d9a67430"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">global::System.Threading.Tasks.Task<br class="typebreak"/>
&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html#a259d209686bd859152aa452f7e21c9a1">CreateAsync</a> (<a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1CreateSpec.html">vmware.vcenter.HostTypes.CreateSpec</a> spec)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new standalone host in the vCenter inventory.  <a href="#a259d209686bd859152aa452f7e21c9a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">global::System.Threading.Tasks.Task<br class="typebreak"/>
&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html#a27c7804c20f3d0a338635ce808c227e3">CreateAsync</a> (<a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1CreateSpec.html">vmware.vcenter.HostTypes.CreateSpec</a> spec, global::System.Action&lt; vmware.vapi.std.Progress &gt; _progress, vmware.vapi.bindings.client.InvocationConfig _invocationConfig)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new standalone host in the vCenter inventory.  <a href="#a27c7804c20f3d0a338635ce808c227e3"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html#a7230a11533ae3915f7d3485f355e6414">Delete</a> (string host)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a standalone host from the vCenter Server.  <a href="#a7230a11533ae3915f7d3485f355e6414"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html#a540d777c96008d61cc7af0e04102f682">Delete</a> (string host, global::System.Action&lt; vmware.vapi.std.Progress &gt; _progress, vmware.vapi.bindings.client.InvocationConfig _invocationConfig)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a standalone host from the vCenter Server.  <a href="#a540d777c96008d61cc7af0e04102f682"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">global::System.Threading.Tasks.Task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html#a186cb970dfb47933bbca7a2008062f6f">DeleteAsync</a> (string host)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a standalone host from the vCenter Server.  <a href="#a186cb970dfb47933bbca7a2008062f6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">global::System.Threading.Tasks.Task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html#a50aae81406e2dc2d2f7a6c7b7c88ea93">DeleteAsync</a> (string host, global::System.Action&lt; vmware.vapi.std.Progress &gt; _progress, vmware.vapi.bindings.client.InvocationConfig _invocationConfig)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a standalone host from the vCenter Server.  <a href="#a50aae81406e2dc2d2f7a6c7b7c88ea93"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">global::System.Collections.Generic.List<br class="typebreak"/>
&lt; <a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1Summary.html">vmware.vcenter.HostTypes.Summary</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html#a9567cd31bae67b7d3c7794be930b25ba">List</a> (<a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1FilterSpec.html">vmware.vcenter.HostTypes.FilterSpec</a> filter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information about at most 2500 visible (subject to permission checks) hosts in vCenter matching the Host.FilterSpec .  <a href="#a9567cd31bae67b7d3c7794be930b25ba"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">global::System.Collections.Generic.List<br class="typebreak"/>
&lt; <a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1Summary.html">vmware.vcenter.HostTypes.Summary</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html#aa558e352a6a7e712a9fad3c983ba1f0b">List</a> (<a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1FilterSpec.html">vmware.vcenter.HostTypes.FilterSpec</a> filter, global::System.Action&lt; vmware.vapi.std.Progress &gt; _progress, vmware.vapi.bindings.client.InvocationConfig _invocationConfig)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information about at most 2500 visible (subject to permission checks) hosts in vCenter matching the Host.FilterSpec .  <a href="#aa558e352a6a7e712a9fad3c983ba1f0b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">global::System.Threading.Tasks.Task<br class="typebreak"/>
&lt; global::System.Collections.Generic.List<br class="typebreak"/>
&lt; <a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1Summary.html">vmware.vcenter.HostTypes.Summary</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html#a60a6b672bdc2f7540e62c2125fa94125">ListAsync</a> (<a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1FilterSpec.html">vmware.vcenter.HostTypes.FilterSpec</a> filter)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information about at most 2500 visible (subject to permission checks) hosts in vCenter matching the Host.FilterSpec .  <a href="#a60a6b672bdc2f7540e62c2125fa94125"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">global::System.Threading.Tasks.Task<br class="typebreak"/>
&lt; global::System.Collections.Generic.List<br class="typebreak"/>
&lt; <a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1Summary.html">vmware.vcenter.HostTypes.Summary</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html#a0143cde6f7786a03b1a6dbe09b9d5ee2">ListAsync</a> (<a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1FilterSpec.html">vmware.vcenter.HostTypes.FilterSpec</a> filter, global::System.Action&lt; vmware.vapi.std.Progress &gt; _progress, vmware.vapi.bindings.client.InvocationConfig _invocationConfig)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns information about at most 2500 visible (subject to permission checks) hosts in vCenter matching the Host.FilterSpec .  <a href="#a0143cde6f7786a03b1a6dbe09b9d5ee2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html#a9dc86308a37146c7cbbacbedba8919bd">Connect</a> (string host)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to the host corresponding to <em>host</em>  previously added to the vCenter server.  <a href="#a9dc86308a37146c7cbbacbedba8919bd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html#afaca33651ec1cad26da92d1c7c139dbd">Connect</a> (string host, global::System.Action&lt; vmware.vapi.std.Progress &gt; _progress, vmware.vapi.bindings.client.InvocationConfig _invocationConfig)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to the host corresponding to <em>host</em>  previously added to the vCenter server.  <a href="#afaca33651ec1cad26da92d1c7c139dbd"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">global::System.Threading.Tasks.Task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html#a5403d3e66a06cf6b4fa9ca1327622a3c">ConnectAsync</a> (string host)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to the host corresponding to <em>host</em>  previously added to the vCenter server.  <a href="#a5403d3e66a06cf6b4fa9ca1327622a3c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">global::System.Threading.Tasks.Task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html#a8dea6be4d0d262820e668d76d2aaa09e">ConnectAsync</a> (string host, global::System.Action&lt; vmware.vapi.std.Progress &gt; _progress, vmware.vapi.bindings.client.InvocationConfig _invocationConfig)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Connect to the host corresponding to <em>host</em>  previously added to the vCenter server.  <a href="#a8dea6be4d0d262820e668d76d2aaa09e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html#adc3ef760adeafd9c14c668400c20232a">Disconnect</a> (string host)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect the host corresponding to <em>host</em>  from the vCenter server.  <a href="#adc3ef760adeafd9c14c668400c20232a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html#a84700bfb60c9cd0c7eefe559c0fbb986">Disconnect</a> (string host, global::System.Action&lt; vmware.vapi.std.Progress &gt; _progress, vmware.vapi.bindings.client.InvocationConfig _invocationConfig)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect the host corresponding to <em>host</em>  from the vCenter server.  <a href="#a84700bfb60c9cd0c7eefe559c0fbb986"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">global::System.Threading.Tasks.Task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html#a995c1c646980632cc1db9fedce055295">DisconnectAsync</a> (string host)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect the host corresponding to <em>host</em>  from the vCenter server.  <a href="#a995c1c646980632cc1db9fedce055295"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">global::System.Threading.Tasks.Task&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html#ab40bade644c2c201ed35d3c6e580cea3">DisconnectAsync</a> (string host, global::System.Action&lt; vmware.vapi.std.Progress &gt; _progress, vmware.vapi.bindings.client.InvocationConfig _invocationConfig)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Disconnect the host corresponding to <em>host</em>  from the vCenter server.  <a href="#ab40bade644c2c201ed35d3c6e580cea3"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The <code><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html" title="The Host interface provides methods to manage hosts in the vCenter Server.">Host</a></code> interface provides methods to manage hosts in the vCenter Server. </p>
</div><hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9dc86308a37146c7cbbacbedba8919bd"></a><!-- doxytag: member="vmware::vcenter::Host::Connect" ref="a9dc86308a37146c7cbbacbedba8919bd" args="(string host)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmware::vcenter::Host::Connect </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect to the host corresponding to <em>host</em>  previously added to the vCenter server. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">vmware.vapi.std.errors.AlreadyInDesiredState</td><td>if the host associated with <em>host</em>  is already connected. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Error</td><td>if the system reports an error while responding to the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.NotFound</td><td>if there is no host associated with <em>host</em>  in the system. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ServiceUnavailable</td><td>if the system is unable to communicate with a service to complete the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user can not be authenticated. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthorized</td><td>if the user doesn't have the required privileges. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Identifier of the host to be reconnected. The parameter must be an identifier for the resource type: <code>HostSystem</code> . </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classvmware_1_1vcenter_1_1HostStub.html#acb1ca9f293b5bffc6fec1255f8af19bf">vmware::vcenter::HostStub</a>.</p>

</div>
</div>
<a class="anchor" id="afaca33651ec1cad26da92d1c7c139dbd"></a><!-- doxytag: member="vmware::vcenter::Host::Connect" ref="afaca33651ec1cad26da92d1c7c139dbd" args="(string host, global::System.Action&lt; vmware.vapi.std.Progress &gt; _progress, vmware.vapi.bindings.client.InvocationConfig _invocationConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmware::vcenter::Host::Connect </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global::System.Action&lt; vmware.vapi.std.Progress &gt;&#160;</td>
          <td class="paramname"><em>_progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vmware.vapi.bindings.client.InvocationConfig&#160;</td>
          <td class="paramname"><em>_invocationConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect to the host corresponding to <em>host</em>  previously added to the vCenter server. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">vmware.vapi.std.errors.AlreadyInDesiredState</td><td>if the host associated with <em>host</em>  is already connected. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Error</td><td>if the system reports an error while responding to the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.NotFound</td><td>if there is no host associated with <em>host</em>  in the system. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ServiceUnavailable</td><td>if the system is unable to communicate with a service to complete the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user can not be authenticated. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthorized</td><td>if the user doesn't have the required privileges. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Identifier of the host to be reconnected. The parameter must be an identifier for the resource type: <code>HostSystem</code> . </td></tr>
    <tr><td class="paramname">_progress</td><td>Progress notification call back </td></tr>
    <tr><td class="paramname">_invocationConfig</td><td>Configuration for the method invocation </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classvmware_1_1vcenter_1_1HostStub.html#a0f0f8048704d7df209be0a363c47bffb">vmware::vcenter::HostStub</a>.</p>

</div>
</div>
<a class="anchor" id="a8dea6be4d0d262820e668d76d2aaa09e"></a><!-- doxytag: member="vmware::vcenter::Host::ConnectAsync" ref="a8dea6be4d0d262820e668d76d2aaa09e" args="(string host, global::System.Action&lt; vmware.vapi.std.Progress &gt; _progress, vmware.vapi.bindings.client.InvocationConfig _invocationConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">global::System.Threading.Tasks.Task vmware::vcenter::Host::ConnectAsync </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global::System.Action&lt; vmware.vapi.std.Progress &gt;&#160;</td>
          <td class="paramname"><em>_progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vmware.vapi.bindings.client.InvocationConfig&#160;</td>
          <td class="paramname"><em>_invocationConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect to the host corresponding to <em>host</em>  previously added to the vCenter server. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">vmware.vapi.std.errors.AlreadyInDesiredState</td><td>if the host associated with <em>host</em>  is already connected. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Error</td><td>if the system reports an error while responding to the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.NotFound</td><td>if there is no host associated with <em>host</em>  in the system. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ServiceUnavailable</td><td>if the system is unable to communicate with a service to complete the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user can not be authenticated. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthorized</td><td>if the user doesn't have the required privileges. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Identifier of the host to be reconnected. The parameter must be an identifier for the resource type: <code>HostSystem</code> . </td></tr>
    <tr><td class="paramname">_progress</td><td>Progress notification call back </td></tr>
    <tr><td class="paramname">_invocationConfig</td><td>Configuration for the method invocation </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classvmware_1_1vcenter_1_1HostStub.html#a8c2c04845b2272bf97fa13a605de4ac4">vmware::vcenter::HostStub</a>.</p>

</div>
</div>
<a class="anchor" id="a5403d3e66a06cf6b4fa9ca1327622a3c"></a><!-- doxytag: member="vmware::vcenter::Host::ConnectAsync" ref="a5403d3e66a06cf6b4fa9ca1327622a3c" args="(string host)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">global::System.Threading.Tasks.Task vmware::vcenter::Host::ConnectAsync </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Connect to the host corresponding to <em>host</em>  previously added to the vCenter server. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">vmware.vapi.std.errors.AlreadyInDesiredState</td><td>if the host associated with <em>host</em>  is already connected. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Error</td><td>if the system reports an error while responding to the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.NotFound</td><td>if there is no host associated with <em>host</em>  in the system. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ServiceUnavailable</td><td>if the system is unable to communicate with a service to complete the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user can not be authenticated. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthorized</td><td>if the user doesn't have the required privileges. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Identifier of the host to be reconnected. The parameter must be an identifier for the resource type: <code>HostSystem</code> . </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classvmware_1_1vcenter_1_1HostStub.html#afb4d39d165f9364beb3fcf7d4209ecfe">vmware::vcenter::HostStub</a>.</p>

</div>
</div>
<a class="anchor" id="a5abd97e980f62febc5400415d9a67430"></a><!-- doxytag: member="vmware::vcenter::Host::Create" ref="a5abd97e980f62febc5400415d9a67430" args="(vmware.vcenter.HostTypes.CreateSpec spec, global::System.Action&lt; vmware.vapi.std.Progress &gt; _progress, vmware.vapi.bindings.client.InvocationConfig _invocationConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vmware::vcenter::Host::Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1CreateSpec.html">vmware.vcenter.HostTypes.CreateSpec</a>&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global::System.Action&lt; vmware.vapi.std.Progress &gt;&#160;</td>
          <td class="paramname"><em>_progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vmware.vapi.bindings.client.InvocationConfig&#160;</td>
          <td class="paramname"><em>_invocationConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new standalone host in the vCenter inventory. </p>
<p>The newly connected host will be in connected state. The vCenter Server will verify the SSL certificate before adding the host to its inventory. In the case where the SSL certificate cannot be verified because the Certificate Authority is not recognized or the certificate is self signed, the vCenter Server will fall back to thumbprint verification mode as defined by Host.CreateSpec.ThumbprintVerification .</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">vmware.vapi.std.errors.AlreadyExists</td><td>if the host with the same name is already present. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Error</td><td>if installation of VirtualCenter agent on a host fails. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Error</td><td>if the system reports an error while responding to the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.InvalidArgument</td><td>if the host name is invalid. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.InvalidArgument</td><td>if the host folder is invalid. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.InvalidArgument</td><td>if the SSL thumbprint specified is invalid. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.InvalidElementType</td><td>if the host folder id does not support vSphere compute resource as its children type. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.NotFound</td><td>if there is no folder associated with the <code>folder</code> field in the system. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ResourceInUse</td><td>if the host is already being managed by another vCenter Server </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.UnableToAllocateResource</td><td>if there are not enough licenses to add the host. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user name or password for the administration account on the host are invalid. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user can not be authenticated. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unsupported</td><td>if the software version on the host is not supported. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ServiceUnavailable</td><td>if the system is unable to communicate with a service to complete the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthorized</td><td>if the user doesn't have the required privileges. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spec</td><td>Specification for the new host to be created. </td></tr>
    <tr><td class="paramname">_progress</td><td>Progress notification call back </td></tr>
    <tr><td class="paramname">_invocationConfig</td><td>Configuration for the method invocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The newly created identifier of the host in vCenter. The result will be an identifier for the resource type: <code>HostSystem</code> . </dd></dl>

<p>Implemented in <a class="el" href="classvmware_1_1vcenter_1_1HostStub.html#a181d036ae2552fb06076c1e98d542d87">vmware::vcenter::HostStub</a>.</p>

</div>
</div>
<a class="anchor" id="a4f42185e7c162aec3fcdca5b10cd9877"></a><!-- doxytag: member="vmware::vcenter::Host::Create" ref="a4f42185e7c162aec3fcdca5b10cd9877" args="(vmware.vcenter.HostTypes.CreateSpec spec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vmware::vcenter::Host::Create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1CreateSpec.html">vmware.vcenter.HostTypes.CreateSpec</a>&#160;</td>
          <td class="paramname"><em>spec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new standalone host in the vCenter inventory. </p>
<p>The newly connected host will be in connected state. The vCenter Server will verify the SSL certificate before adding the host to its inventory. In the case where the SSL certificate cannot be verified because the Certificate Authority is not recognized or the certificate is self signed, the vCenter Server will fall back to thumbprint verification mode as defined by Host.CreateSpec.ThumbprintVerification .</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">vmware.vapi.std.errors.AlreadyExists</td><td>if the host with the same name is already present. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Error</td><td>if installation of VirtualCenter agent on a host fails. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Error</td><td>if the system reports an error while responding to the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.InvalidArgument</td><td>if the host name is invalid. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.InvalidArgument</td><td>if the host folder is invalid. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.InvalidArgument</td><td>if the SSL thumbprint specified is invalid. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.InvalidElementType</td><td>if the host folder id does not support vSphere compute resource as its children type. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.NotFound</td><td>if there is no folder associated with the <code>folder</code> field in the system. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ResourceInUse</td><td>if the host is already being managed by another vCenter Server </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.UnableToAllocateResource</td><td>if there are not enough licenses to add the host. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user name or password for the administration account on the host are invalid. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user can not be authenticated. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unsupported</td><td>if the software version on the host is not supported. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ServiceUnavailable</td><td>if the system is unable to communicate with a service to complete the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthorized</td><td>if the user doesn't have the required privileges. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spec</td><td>Specification for the new host to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The newly created identifier of the host in vCenter. The result will be an identifier for the resource type: <code>HostSystem</code> . </dd></dl>

<p>Implemented in <a class="el" href="classvmware_1_1vcenter_1_1HostStub.html#ac8ae75ba36c5a8adb78f97ac7e6d61d2">vmware::vcenter::HostStub</a>.</p>

</div>
</div>
<a class="anchor" id="a27c7804c20f3d0a338635ce808c227e3"></a><!-- doxytag: member="vmware::vcenter::Host::CreateAsync" ref="a27c7804c20f3d0a338635ce808c227e3" args="(vmware.vcenter.HostTypes.CreateSpec spec, global::System.Action&lt; vmware.vapi.std.Progress &gt; _progress, vmware.vapi.bindings.client.InvocationConfig _invocationConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">global::System.Threading.Tasks.Task&lt;string&gt; vmware::vcenter::Host::CreateAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1CreateSpec.html">vmware.vcenter.HostTypes.CreateSpec</a>&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global::System.Action&lt; vmware.vapi.std.Progress &gt;&#160;</td>
          <td class="paramname"><em>_progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vmware.vapi.bindings.client.InvocationConfig&#160;</td>
          <td class="paramname"><em>_invocationConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new standalone host in the vCenter inventory. </p>
<p>The newly connected host will be in connected state. The vCenter Server will verify the SSL certificate before adding the host to its inventory. In the case where the SSL certificate cannot be verified because the Certificate Authority is not recognized or the certificate is self signed, the vCenter Server will fall back to thumbprint verification mode as defined by Host.CreateSpec.ThumbprintVerification .</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">vmware.vapi.std.errors.AlreadyExists</td><td>if the host with the same name is already present. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Error</td><td>if installation of VirtualCenter agent on a host fails. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Error</td><td>if the system reports an error while responding to the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.InvalidArgument</td><td>if the host name is invalid. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.InvalidArgument</td><td>if the host folder is invalid. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.InvalidArgument</td><td>if the SSL thumbprint specified is invalid. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.InvalidElementType</td><td>if the host folder id does not support vSphere compute resource as its children type. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.NotFound</td><td>if there is no folder associated with the <code>folder</code> field in the system. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ResourceInUse</td><td>if the host is already being managed by another vCenter Server </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.UnableToAllocateResource</td><td>if there are not enough licenses to add the host. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user name or password for the administration account on the host are invalid. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user can not be authenticated. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unsupported</td><td>if the software version on the host is not supported. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ServiceUnavailable</td><td>if the system is unable to communicate with a service to complete the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthorized</td><td>if the user doesn't have the required privileges. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spec</td><td>Specification for the new host to be created. </td></tr>
    <tr><td class="paramname">_progress</td><td>Progress notification call back </td></tr>
    <tr><td class="paramname">_invocationConfig</td><td>Configuration for the method invocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The newly created identifier of the host in vCenter. The result will be an identifier for the resource type: <code>HostSystem</code> . </dd></dl>

<p>Implemented in <a class="el" href="classvmware_1_1vcenter_1_1HostStub.html#aaa6852e64f85a401a121767dd7aeacec">vmware::vcenter::HostStub</a>.</p>

</div>
</div>
<a class="anchor" id="a259d209686bd859152aa452f7e21c9a1"></a><!-- doxytag: member="vmware::vcenter::Host::CreateAsync" ref="a259d209686bd859152aa452f7e21c9a1" args="(vmware.vcenter.HostTypes.CreateSpec spec)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">global::System.Threading.Tasks.Task&lt;string&gt; vmware::vcenter::Host::CreateAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1CreateSpec.html">vmware.vcenter.HostTypes.CreateSpec</a>&#160;</td>
          <td class="paramname"><em>spec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Add a new standalone host in the vCenter inventory. </p>
<p>The newly connected host will be in connected state. The vCenter Server will verify the SSL certificate before adding the host to its inventory. In the case where the SSL certificate cannot be verified because the Certificate Authority is not recognized or the certificate is self signed, the vCenter Server will fall back to thumbprint verification mode as defined by Host.CreateSpec.ThumbprintVerification .</p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">vmware.vapi.std.errors.AlreadyExists</td><td>if the host with the same name is already present. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Error</td><td>if installation of VirtualCenter agent on a host fails. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Error</td><td>if the system reports an error while responding to the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.InvalidArgument</td><td>if the host name is invalid. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.InvalidArgument</td><td>if the host folder is invalid. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.InvalidArgument</td><td>if the SSL thumbprint specified is invalid. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.InvalidElementType</td><td>if the host folder id does not support vSphere compute resource as its children type. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.NotFound</td><td>if there is no folder associated with the <code>folder</code> field in the system. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ResourceInUse</td><td>if the host is already being managed by another vCenter Server </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.UnableToAllocateResource</td><td>if there are not enough licenses to add the host. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user name or password for the administration account on the host are invalid. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user can not be authenticated. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unsupported</td><td>if the software version on the host is not supported. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ServiceUnavailable</td><td>if the system is unable to communicate with a service to complete the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthorized</td><td>if the user doesn't have the required privileges. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">spec</td><td>Specification for the new host to be created. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The newly created identifier of the host in vCenter. The result will be an identifier for the resource type: <code>HostSystem</code> . </dd></dl>

<p>Implemented in <a class="el" href="classvmware_1_1vcenter_1_1HostStub.html#af54f961b4f91b2feb6ceaf14a7b6a1d7">vmware::vcenter::HostStub</a>.</p>

</div>
</div>
<a class="anchor" id="a7230a11533ae3915f7d3485f355e6414"></a><!-- doxytag: member="vmware::vcenter::Host::Delete" ref="a7230a11533ae3915f7d3485f355e6414" args="(string host)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmware::vcenter::Host::Delete </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a standalone host from the vCenter Server. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">vmware.vapi.std.errors.Error</td><td>if the system reports an error while responding to the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.NotFound</td><td>if there is no host associated with <em>host</em>  in the system. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ResourceInUse</td><td>if the host associated with <em>host</em>  is in a vCenter cluster </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ServiceUnavailable</td><td>if the system is unable to communicate with a service to complete the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user can not be authenticated. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthorized</td><td>if the user doesn't have the required privileges. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Identifier of the host to be deleted. The parameter must be an identifier for the resource type: <code>HostSystem</code> . </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classvmware_1_1vcenter_1_1HostStub.html#a1baf6e94403f707eb149b53b9834c1d4">vmware::vcenter::HostStub</a>.</p>

</div>
</div>
<a class="anchor" id="a540d777c96008d61cc7af0e04102f682"></a><!-- doxytag: member="vmware::vcenter::Host::Delete" ref="a540d777c96008d61cc7af0e04102f682" args="(string host, global::System.Action&lt; vmware.vapi.std.Progress &gt; _progress, vmware.vapi.bindings.client.InvocationConfig _invocationConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmware::vcenter::Host::Delete </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global::System.Action&lt; vmware.vapi.std.Progress &gt;&#160;</td>
          <td class="paramname"><em>_progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vmware.vapi.bindings.client.InvocationConfig&#160;</td>
          <td class="paramname"><em>_invocationConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a standalone host from the vCenter Server. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">vmware.vapi.std.errors.Error</td><td>if the system reports an error while responding to the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.NotFound</td><td>if there is no host associated with <em>host</em>  in the system. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ResourceInUse</td><td>if the host associated with <em>host</em>  is in a vCenter cluster </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ServiceUnavailable</td><td>if the system is unable to communicate with a service to complete the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user can not be authenticated. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthorized</td><td>if the user doesn't have the required privileges. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Identifier of the host to be deleted. The parameter must be an identifier for the resource type: <code>HostSystem</code> . </td></tr>
    <tr><td class="paramname">_progress</td><td>Progress notification call back </td></tr>
    <tr><td class="paramname">_invocationConfig</td><td>Configuration for the method invocation </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classvmware_1_1vcenter_1_1HostStub.html#a9196527012df1ff62bdeb4cff2f7817d">vmware::vcenter::HostStub</a>.</p>

</div>
</div>
<a class="anchor" id="a50aae81406e2dc2d2f7a6c7b7c88ea93"></a><!-- doxytag: member="vmware::vcenter::Host::DeleteAsync" ref="a50aae81406e2dc2d2f7a6c7b7c88ea93" args="(string host, global::System.Action&lt; vmware.vapi.std.Progress &gt; _progress, vmware.vapi.bindings.client.InvocationConfig _invocationConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">global::System.Threading.Tasks.Task vmware::vcenter::Host::DeleteAsync </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global::System.Action&lt; vmware.vapi.std.Progress &gt;&#160;</td>
          <td class="paramname"><em>_progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vmware.vapi.bindings.client.InvocationConfig&#160;</td>
          <td class="paramname"><em>_invocationConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a standalone host from the vCenter Server. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">vmware.vapi.std.errors.Error</td><td>if the system reports an error while responding to the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.NotFound</td><td>if there is no host associated with <em>host</em>  in the system. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ResourceInUse</td><td>if the host associated with <em>host</em>  is in a vCenter cluster </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ServiceUnavailable</td><td>if the system is unable to communicate with a service to complete the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user can not be authenticated. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthorized</td><td>if the user doesn't have the required privileges. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Identifier of the host to be deleted. The parameter must be an identifier for the resource type: <code>HostSystem</code> . </td></tr>
    <tr><td class="paramname">_progress</td><td>Progress notification call back </td></tr>
    <tr><td class="paramname">_invocationConfig</td><td>Configuration for the method invocation </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classvmware_1_1vcenter_1_1HostStub.html#a0eab6a0f98293ee0b229d73a489a5558">vmware::vcenter::HostStub</a>.</p>

</div>
</div>
<a class="anchor" id="a186cb970dfb47933bbca7a2008062f6f"></a><!-- doxytag: member="vmware::vcenter::Host::DeleteAsync" ref="a186cb970dfb47933bbca7a2008062f6f" args="(string host)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">global::System.Threading.Tasks.Task vmware::vcenter::Host::DeleteAsync </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Remove a standalone host from the vCenter Server. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">vmware.vapi.std.errors.Error</td><td>if the system reports an error while responding to the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.NotFound</td><td>if there is no host associated with <em>host</em>  in the system. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ResourceInUse</td><td>if the host associated with <em>host</em>  is in a vCenter cluster </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ServiceUnavailable</td><td>if the system is unable to communicate with a service to complete the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user can not be authenticated. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthorized</td><td>if the user doesn't have the required privileges. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Identifier of the host to be deleted. The parameter must be an identifier for the resource type: <code>HostSystem</code> . </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classvmware_1_1vcenter_1_1HostStub.html#a69ad50570c841242f38abd6ec069a249">vmware::vcenter::HostStub</a>.</p>

</div>
</div>
<a class="anchor" id="adc3ef760adeafd9c14c668400c20232a"></a><!-- doxytag: member="vmware::vcenter::Host::Disconnect" ref="adc3ef760adeafd9c14c668400c20232a" args="(string host)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmware::vcenter::Host::Disconnect </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnect the host corresponding to <em>host</em>  from the vCenter server. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">vmware.vapi.std.errors.AlreadyInDesiredState</td><td>if the host associated with <em>host</em>  is already disconnected. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Error</td><td>if the system reports an error while responding to the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.NotFound</td><td>if there is no host associated with <em>host</em>  in the system. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ServiceUnavailable</td><td>if the system is unable to communicate with a service to complete the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user can not be authenticated. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthorized</td><td>if the user doesn't have the required privileges. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Identifier of the host to be disconnected. The parameter must be an identifier for the resource type: <code>HostSystem</code> . </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classvmware_1_1vcenter_1_1HostStub.html#accc799d6ef7af60816abf98bb568cc4a">vmware::vcenter::HostStub</a>.</p>

</div>
</div>
<a class="anchor" id="a84700bfb60c9cd0c7eefe559c0fbb986"></a><!-- doxytag: member="vmware::vcenter::Host::Disconnect" ref="a84700bfb60c9cd0c7eefe559c0fbb986" args="(string host, global::System.Action&lt; vmware.vapi.std.Progress &gt; _progress, vmware.vapi.bindings.client.InvocationConfig _invocationConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vmware::vcenter::Host::Disconnect </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global::System.Action&lt; vmware.vapi.std.Progress &gt;&#160;</td>
          <td class="paramname"><em>_progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vmware.vapi.bindings.client.InvocationConfig&#160;</td>
          <td class="paramname"><em>_invocationConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnect the host corresponding to <em>host</em>  from the vCenter server. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">vmware.vapi.std.errors.AlreadyInDesiredState</td><td>if the host associated with <em>host</em>  is already disconnected. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Error</td><td>if the system reports an error while responding to the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.NotFound</td><td>if there is no host associated with <em>host</em>  in the system. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ServiceUnavailable</td><td>if the system is unable to communicate with a service to complete the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user can not be authenticated. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthorized</td><td>if the user doesn't have the required privileges. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Identifier of the host to be disconnected. The parameter must be an identifier for the resource type: <code>HostSystem</code> . </td></tr>
    <tr><td class="paramname">_progress</td><td>Progress notification call back </td></tr>
    <tr><td class="paramname">_invocationConfig</td><td>Configuration for the method invocation </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classvmware_1_1vcenter_1_1HostStub.html#a490e081e773b87bc06b155f0f1d13353">vmware::vcenter::HostStub</a>.</p>

</div>
</div>
<a class="anchor" id="ab40bade644c2c201ed35d3c6e580cea3"></a><!-- doxytag: member="vmware::vcenter::Host::DisconnectAsync" ref="ab40bade644c2c201ed35d3c6e580cea3" args="(string host, global::System.Action&lt; vmware.vapi.std.Progress &gt; _progress, vmware.vapi.bindings.client.InvocationConfig _invocationConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">global::System.Threading.Tasks.Task vmware::vcenter::Host::DisconnectAsync </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global::System.Action&lt; vmware.vapi.std.Progress &gt;&#160;</td>
          <td class="paramname"><em>_progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vmware.vapi.bindings.client.InvocationConfig&#160;</td>
          <td class="paramname"><em>_invocationConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnect the host corresponding to <em>host</em>  from the vCenter server. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">vmware.vapi.std.errors.AlreadyInDesiredState</td><td>if the host associated with <em>host</em>  is already disconnected. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Error</td><td>if the system reports an error while responding to the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.NotFound</td><td>if there is no host associated with <em>host</em>  in the system. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ServiceUnavailable</td><td>if the system is unable to communicate with a service to complete the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user can not be authenticated. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthorized</td><td>if the user doesn't have the required privileges. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Identifier of the host to be disconnected. The parameter must be an identifier for the resource type: <code>HostSystem</code> . </td></tr>
    <tr><td class="paramname">_progress</td><td>Progress notification call back </td></tr>
    <tr><td class="paramname">_invocationConfig</td><td>Configuration for the method invocation </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classvmware_1_1vcenter_1_1HostStub.html#a703adefd5a8e54715710a9a6cb0ea566">vmware::vcenter::HostStub</a>.</p>

</div>
</div>
<a class="anchor" id="a995c1c646980632cc1db9fedce055295"></a><!-- doxytag: member="vmware::vcenter::Host::DisconnectAsync" ref="a995c1c646980632cc1db9fedce055295" args="(string host)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">global::System.Threading.Tasks.Task vmware::vcenter::Host::DisconnectAsync </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>host</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Disconnect the host corresponding to <em>host</em>  from the vCenter server. </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">vmware.vapi.std.errors.AlreadyInDesiredState</td><td>if the host associated with <em>host</em>  is already disconnected. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Error</td><td>if the system reports an error while responding to the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.NotFound</td><td>if there is no host associated with <em>host</em>  in the system. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ServiceUnavailable</td><td>if the system is unable to communicate with a service to complete the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user can not be authenticated. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthorized</td><td>if the user doesn't have the required privileges. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">host</td><td>Identifier of the host to be disconnected. The parameter must be an identifier for the resource type: <code>HostSystem</code> . </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classvmware_1_1vcenter_1_1HostStub.html#ad968bdb01b2f4f39651c96247e1e6a84">vmware::vcenter::HostStub</a>.</p>

</div>
</div>
<a class="anchor" id="a9567cd31bae67b7d3c7794be930b25ba"></a><!-- doxytag: member="vmware::vcenter::Host::List" ref="a9567cd31bae67b7d3c7794be930b25ba" args="(vmware.vcenter.HostTypes.FilterSpec filter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">global::System.Collections.Generic.List&lt;<a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1Summary.html">vmware.vcenter.HostTypes.Summary</a>&gt; vmware::vcenter::Host::List </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1FilterSpec.html">vmware.vcenter.HostTypes.FilterSpec</a>&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns information about at most 2500 visible (subject to permission checks) hosts in vCenter matching the Host.FilterSpec . </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">vmware.vapi.std.errors.InvalidArgument</td><td>if the Host.FilterSpec.connectionStates field contains a value that is not supported by the server. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.UnableToAllocateResource</td><td>if more than 2500 hosts match the Host.FilterSpec . </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ServiceUnavailable</td><td>if the system is unable to communicate with a service to complete the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user can not be authenticated. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthorized</td><td>if the user doesn't have the required privileges. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>Specification of matching hosts for which information should be returned. If null, the behavior is equivalent to a Host.FilterSpec with all fields null which means all hosts match the filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Commonly used information about the hosts matching the Host.FilterSpec . </dd></dl>

<p>Implemented in <a class="el" href="classvmware_1_1vcenter_1_1HostStub.html#ac0cb213a50d3624438a82463293fd90f">vmware::vcenter::HostStub</a>.</p>

</div>
</div>
<a class="anchor" id="aa558e352a6a7e712a9fad3c983ba1f0b"></a><!-- doxytag: member="vmware::vcenter::Host::List" ref="aa558e352a6a7e712a9fad3c983ba1f0b" args="(vmware.vcenter.HostTypes.FilterSpec filter, global::System.Action&lt; vmware.vapi.std.Progress &gt; _progress, vmware.vapi.bindings.client.InvocationConfig _invocationConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">global::System.Collections.Generic.List&lt;<a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1Summary.html">vmware.vcenter.HostTypes.Summary</a>&gt; vmware::vcenter::Host::List </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1FilterSpec.html">vmware.vcenter.HostTypes.FilterSpec</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global::System.Action&lt; vmware.vapi.std.Progress &gt;&#160;</td>
          <td class="paramname"><em>_progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vmware.vapi.bindings.client.InvocationConfig&#160;</td>
          <td class="paramname"><em>_invocationConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns information about at most 2500 visible (subject to permission checks) hosts in vCenter matching the Host.FilterSpec . </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">vmware.vapi.std.errors.InvalidArgument</td><td>if the Host.FilterSpec.connectionStates field contains a value that is not supported by the server. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.UnableToAllocateResource</td><td>if more than 2500 hosts match the Host.FilterSpec . </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ServiceUnavailable</td><td>if the system is unable to communicate with a service to complete the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user can not be authenticated. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthorized</td><td>if the user doesn't have the required privileges. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>Specification of matching hosts for which information should be returned. If null, the behavior is equivalent to a Host.FilterSpec with all fields null which means all hosts match the filter. </td></tr>
    <tr><td class="paramname">_progress</td><td>Progress notification call back </td></tr>
    <tr><td class="paramname">_invocationConfig</td><td>Configuration for the method invocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Commonly used information about the hosts matching the Host.FilterSpec . </dd></dl>

<p>Implemented in <a class="el" href="classvmware_1_1vcenter_1_1HostStub.html#a3e944c55ef1060b9c91573484ef58cfb">vmware::vcenter::HostStub</a>.</p>

</div>
</div>
<a class="anchor" id="a0143cde6f7786a03b1a6dbe09b9d5ee2"></a><!-- doxytag: member="vmware::vcenter::Host::ListAsync" ref="a0143cde6f7786a03b1a6dbe09b9d5ee2" args="(vmware.vcenter.HostTypes.FilterSpec filter, global::System.Action&lt; vmware.vapi.std.Progress &gt; _progress, vmware.vapi.bindings.client.InvocationConfig _invocationConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">global::System.Threading.Tasks.Task&lt;global::System.Collections.Generic.List&lt;<a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1Summary.html">vmware.vcenter.HostTypes.Summary</a>&gt; &gt; vmware::vcenter::Host::ListAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1FilterSpec.html">vmware.vcenter.HostTypes.FilterSpec</a>&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">global::System.Action&lt; vmware.vapi.std.Progress &gt;&#160;</td>
          <td class="paramname"><em>_progress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vmware.vapi.bindings.client.InvocationConfig&#160;</td>
          <td class="paramname"><em>_invocationConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns information about at most 2500 visible (subject to permission checks) hosts in vCenter matching the Host.FilterSpec . </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">vmware.vapi.std.errors.InvalidArgument</td><td>if the Host.FilterSpec.connectionStates field contains a value that is not supported by the server. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.UnableToAllocateResource</td><td>if more than 2500 hosts match the Host.FilterSpec . </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ServiceUnavailable</td><td>if the system is unable to communicate with a service to complete the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user can not be authenticated. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthorized</td><td>if the user doesn't have the required privileges. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>Specification of matching hosts for which information should be returned. If null, the behavior is equivalent to a Host.FilterSpec with all fields null which means all hosts match the filter. </td></tr>
    <tr><td class="paramname">_progress</td><td>Progress notification call back </td></tr>
    <tr><td class="paramname">_invocationConfig</td><td>Configuration for the method invocation </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Commonly used information about the hosts matching the Host.FilterSpec . </dd></dl>

<p>Implemented in <a class="el" href="classvmware_1_1vcenter_1_1HostStub.html#adfb446d3c7d2586a3091dfb600f4a38c">vmware::vcenter::HostStub</a>.</p>

</div>
</div>
<a class="anchor" id="a60a6b672bdc2f7540e62c2125fa94125"></a><!-- doxytag: member="vmware::vcenter::Host::ListAsync" ref="a60a6b672bdc2f7540e62c2125fa94125" args="(vmware.vcenter.HostTypes.FilterSpec filter)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">global::System.Threading.Tasks.Task&lt;global::System.Collections.Generic.List&lt;<a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1Summary.html">vmware.vcenter.HostTypes.Summary</a>&gt; &gt; vmware::vcenter::Host::ListAsync </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvmware_1_1vcenter_1_1HostTypes_1_1FilterSpec.html">vmware.vcenter.HostTypes.FilterSpec</a>&#160;</td>
          <td class="paramname"><em>filter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns information about at most 2500 visible (subject to permission checks) hosts in vCenter matching the Host.FilterSpec . </p>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">vmware.vapi.std.errors.InvalidArgument</td><td>if the Host.FilterSpec.connectionStates field contains a value that is not supported by the server. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.UnableToAllocateResource</td><td>if more than 2500 hosts match the Host.FilterSpec . </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.ServiceUnavailable</td><td>if the system is unable to communicate with a service to complete the request. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthenticated</td><td>if the user can not be authenticated. </td></tr>
    <tr><td class="paramname">vmware.vapi.std.errors.Unauthorized</td><td>if the user doesn't have the required privileges. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">filter</td><td>Specification of matching hosts for which information should be returned. If null, the behavior is equivalent to a Host.FilterSpec with all fields null which means all hosts match the filter. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Commonly used information about the hosts matching the Host.FilterSpec . </dd></dl>

<p>Implemented in <a class="el" href="classvmware_1_1vcenter_1_1HostStub.html#a7a94298d0a4d56f23425350be3d72fd5">vmware::vcenter::HostStub</a>.</p>

</div>
</div>
<hr/>The documentation for this interface was generated from the following file:<ul>
<li><a class="el" href="Host_8cs.html">Host.cs</a></li>
</ul>
</div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespacevmware.html">vmware</a>      </li>
      <li class="navelem"><a class="el" href="namespacevmware_1_1vcenter.html">vcenter</a>      </li>
      <li class="navelem"><a class="el" href="interfacevmware_1_1vcenter_1_1Host.html">Host</a>      </li>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Properties</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


    <li class="footer">&#0169; 2014, 2016 - 2019 VMware, Inc. All rights reserved. |
 Version 6.7.2 </li>
   </ul>
 </div>


</body>
</html>
